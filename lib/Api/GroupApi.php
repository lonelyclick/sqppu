<?php
/**
 * GroupApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Distributor PPU Service
 *
 * Â© KnowRoaming LTD 2017
 *
 * OpenAPI spec version: v1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.35
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * GroupApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class GroupApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adjustGroupBalance
     *
     * Modify the balance of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestAdjustBalance $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adjustGroupBalance($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->adjustGroupBalanceWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation adjustGroupBalanceWithHttpInfo
     *
     * Modify the balance of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestAdjustBalance $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adjustGroupBalanceWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->adjustGroupBalanceRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adjustGroupBalanceAsync
     *
     * Modify the balance of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestAdjustBalance $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adjustGroupBalanceAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->adjustGroupBalanceAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adjustGroupBalanceAsyncWithHttpInfo
     *
     * Modify the balance of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestAdjustBalance $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adjustGroupBalanceAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->adjustGroupBalanceRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adjustGroupBalance'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestAdjustBalance $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function adjustGroupBalanceRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling adjustGroupBalance'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adjustGroupBalance'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/adjustBalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGroupSubgroup
     *
     * Create a sub-group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestSubgroup $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseGroup
     */
    public function createGroupSubgroup($distributor_id, $group_id, $body = null, $request_id = null)
    {
        list($response) = $this->createGroupSubgroupWithHttpInfo($distributor_id, $group_id, $body, $request_id);
        return $response;
    }

    /**
     * Operation createGroupSubgroupWithHttpInfo
     *
     * Create a sub-group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestSubgroup $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGroupSubgroupWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroup';
        $request = $this->createGroupSubgroupRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createGroupSubgroupAsync
     *
     * Create a sub-group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestSubgroup $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGroupSubgroupAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->createGroupSubgroupAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGroupSubgroupAsyncWithHttpInfo
     *
     * Create a sub-group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestSubgroup $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createGroupSubgroupAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroup';
        $request = $this->createGroupSubgroupRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGroupSubgroup'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestSubgroup $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createGroupSubgroupRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling createGroupSubgroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling createGroupSubgroup'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/subGroup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGroup
     *
     * Delete a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteGroup($distributor_id, $group_id, $request_id = null)
    {
        $this->deleteGroupWithHttpInfo($distributor_id, $group_id, $request_id);
    }

    /**
     * Operation deleteGroupWithHttpInfo
     *
     * Delete a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '';
        $request = $this->deleteGroupRequest($distributor_id, $group_id, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGroupAsync
     *
     * Delete a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsync($distributor_id, $group_id, $request_id = null)
    {
        return $this->deleteGroupAsyncWithHttpInfo($distributor_id, $group_id, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupAsyncWithHttpInfo
     *
     * Delete a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGroupAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '';
        $request = $this->deleteGroupRequest($distributor_id, $group_id, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGroup'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGroupRequest($distributor_id, $group_id, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling deleteGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling deleteGroup'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getALegDataEntries
     *
     * Get a list of A Leg rates for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseRateEntryALegData
     */
    public function getALegDataEntries($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        list($response) = $this->getALegDataEntriesWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort);
        return $response;
    }

    /**
     * Operation getALegDataEntriesWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseRateEntryALegData, HTTP status code, HTTP response headers (array of strings)
     */
    public function getALegDataEntriesWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegData';
        $request = $this->getALegDataEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseRateEntryALegData',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getALegDataEntriesAsync
     *
     * Get a list of A Leg rates for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegDataEntriesAsync($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        return $this->getALegDataEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getALegDataEntriesAsyncWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegDataEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegData';
        $request = $this->getALegDataEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getALegDataEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getALegDataEntriesRequest($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getALegDataEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getALegDataEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/dataalegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, 'int32');
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getALegSmsEntries
     *
     * Get a list of A Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseRateEntryALegSms
     */
    public function getALegSmsEntries($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        list($response) = $this->getALegSmsEntriesWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort);
        return $response;
    }

    /**
     * Operation getALegSmsEntriesWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseRateEntryALegSms, HTTP status code, HTTP response headers (array of strings)
     */
    public function getALegSmsEntriesWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegSms';
        $request = $this->getALegSmsEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseRateEntryALegSms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getALegSmsEntriesAsync
     *
     * Get a list of A Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegSmsEntriesAsync($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        return $this->getALegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getALegSmsEntriesAsyncWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegSms';
        $request = $this->getALegSmsEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getALegSmsEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getALegSmsEntriesRequest($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getALegSmsEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getALegSmsEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/smsalegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, 'int32');
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getALegVoiceEntries
     *
     * Get a list of A Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseRateEntryALegVoice
     */
    public function getALegVoiceEntries($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        list($response) = $this->getALegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort);
        return $response;
    }

    /**
     * Operation getALegVoiceEntriesWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseRateEntryALegVoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getALegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegVoice';
        $request = $this->getALegVoiceEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseRateEntryALegVoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getALegVoiceEntriesAsync
     *
     * Get a list of A Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegVoiceEntriesAsync($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        return $this->getALegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getALegVoiceEntriesAsyncWithHttpInfo
     *
     * Get a list of A Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getALegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryALegVoice';
        $request = $this->getALegVoiceEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getALegVoiceEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getALegVoiceEntriesRequest($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getALegVoiceEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getALegVoiceEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/voicealegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, 'int32');
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBLegSmsEntries
     *
     * Get a list of B Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 10)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseRateEntryBLegSms
     */
    public function getBLegSmsEntries($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '10', $sort = null)
    {
        list($response) = $this->getBLegSmsEntriesWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort);
        return $response;
    }

    /**
     * Operation getBLegSmsEntriesWithHttpInfo
     *
     * Get a list of B Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 10)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseRateEntryBLegSms, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBLegSmsEntriesWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '10', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryBLegSms';
        $request = $this->getBLegSmsEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseRateEntryBLegSms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBLegSmsEntriesAsync
     *
     * Get a list of B Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 10)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBLegSmsEntriesAsync($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '10', $sort = null)
    {
        return $this->getBLegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBLegSmsEntriesAsyncWithHttpInfo
     *
     * Get a list of B Leg rates for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 10)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBLegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '10', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryBLegSms';
        $request = $this->getBLegSmsEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBLegSmsEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 10)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBLegSmsEntriesRequest($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '10', $sort = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getBLegSmsEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getBLegSmsEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/smsblegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, 'int32');
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBLegVoiceEntries
     *
     * Get a list of B Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseRateEntryBLegVoice
     */
    public function getBLegVoiceEntries($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        list($response) = $this->getBLegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort);
        return $response;
    }

    /**
     * Operation getBLegVoiceEntriesWithHttpInfo
     *
     * Get a list of B Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseRateEntryBLegVoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBLegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryBLegVoice';
        $request = $this->getBLegVoiceEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseRateEntryBLegVoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBLegVoiceEntriesAsync
     *
     * Get a list of B Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBLegVoiceEntriesAsync($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        return $this->getBLegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $start, $rows, $sort)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBLegVoiceEntriesAsyncWithHttpInfo
     *
     * Get a list of B Leg rates for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBLegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseRateEntryBLegVoice';
        $request = $this->getBLegVoiceEntriesRequest($distributor_id, $group_id, $request_id, $start, $rows, $sort);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBLegVoiceEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $start The number of leading results to skip (optional, default to 0)
     * @param  int $rows The number of elements to return (optional, default to 1000000)
     * @param  string $sort The field to sort the elements and the order (asc or desc) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBLegVoiceEntriesRequest($distributor_id, $group_id, $request_id = null, $start = '0', $rows = '1000000', $sort = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getBLegVoiceEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getBLegVoiceEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/voiceblegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, 'int32');
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows, 'int32');
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroup
     *
     * Get a group information
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseGroup
     */
    public function getGroup($distributor_id, $group_id, $request_id = null)
    {
        list($response) = $this->getGroupWithHttpInfo($distributor_id, $group_id, $request_id);
        return $response;
    }

    /**
     * Operation getGroupWithHttpInfo
     *
     * Get a group information
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroup';
        $request = $this->getGroupRequest($distributor_id, $group_id, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupAsync
     *
     * Get a group information
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsync($distributor_id, $group_id, $request_id = null)
    {
        return $this->getGroupAsyncWithHttpInfo($distributor_id, $group_id, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupAsyncWithHttpInfo
     *
     * Get a group information
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroup';
        $request = $this->getGroupRequest($distributor_id, $group_id, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroup'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupRequest($distributor_id, $group_id, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroup'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupBalance
     *
     * Get a group balance
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseBalance
     */
    public function getGroupBalance($distributor_id, $group_id, $request_id = null)
    {
        list($response) = $this->getGroupBalanceWithHttpInfo($distributor_id, $group_id, $request_id);
        return $response;
    }

    /**
     * Operation getGroupBalanceWithHttpInfo
     *
     * Get a group balance
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseBalance, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupBalanceWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBalance';
        $request = $this->getGroupBalanceRequest($distributor_id, $group_id, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseBalance',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupBalanceAsync
     *
     * Get a group balance
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupBalanceAsync($distributor_id, $group_id, $request_id = null)
    {
        return $this->getGroupBalanceAsyncWithHttpInfo($distributor_id, $group_id, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupBalanceAsyncWithHttpInfo
     *
     * Get a group balance
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupBalanceAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseBalance';
        $request = $this->getGroupBalanceRequest($distributor_id, $group_id, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupBalance'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupBalanceRequest($distributor_id, $group_id, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroupBalance'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupBalance'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupDetails
     *
     * Get the details of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseGroupDetails
     */
    public function getGroupDetails($distributor_id, $group_id, $request_id = null)
    {
        list($response) = $this->getGroupDetailsWithHttpInfo($distributor_id, $group_id, $request_id);
        return $response;
    }

    /**
     * Operation getGroupDetailsWithHttpInfo
     *
     * Get the details of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseGroupDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupDetailsWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroupDetails';
        $request = $this->getGroupDetailsRequest($distributor_id, $group_id, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseGroupDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupDetailsAsync
     *
     * Get the details of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupDetailsAsync($distributor_id, $group_id, $request_id = null)
    {
        return $this->getGroupDetailsAsyncWithHttpInfo($distributor_id, $group_id, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupDetailsAsyncWithHttpInfo
     *
     * Get the details of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupDetailsAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseGroupDetails';
        $request = $this->getGroupDetailsRequest($distributor_id, $group_id, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupDetails'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupDetailsRequest($distributor_id, $group_id, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroupDetails'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupDetails'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupOverdraft
     *
     * Get the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseOverdraft
     */
    public function getGroupOverdraft($distributor_id, $group_id, $request_id = null)
    {
        list($response) = $this->getGroupOverdraftWithHttpInfo($distributor_id, $group_id, $request_id);
        return $response;
    }

    /**
     * Operation getGroupOverdraftWithHttpInfo
     *
     * Get the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseOverdraft, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupOverdraftWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseOverdraft';
        $request = $this->getGroupOverdraftRequest($distributor_id, $group_id, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseOverdraft',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupOverdraftAsync
     *
     * Get the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupOverdraftAsync($distributor_id, $group_id, $request_id = null)
    {
        return $this->getGroupOverdraftAsyncWithHttpInfo($distributor_id, $group_id, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupOverdraftAsyncWithHttpInfo
     *
     * Get the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupOverdraftAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseOverdraft';
        $request = $this->getGroupOverdraftRequest($distributor_id, $group_id, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupOverdraft'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupOverdraftRequest($distributor_id, $group_id, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroupOverdraft'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupOverdraft'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/overdraft';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupSims
     *
     * Get SIMs owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseSim
     */
    public function getGroupSims($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        list($response) = $this->getGroupSimsWithHttpInfo($distributor_id, $group_id, $request_id, $offset, $count);
        return $response;
    }

    /**
     * Operation getGroupSimsWithHttpInfo
     *
     * Get SIMs owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseSim, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupSimsWithHttpInfo($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseSim';
        $request = $this->getGroupSimsRequest($distributor_id, $group_id, $request_id, $offset, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseSim',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupSimsAsync
     *
     * Get SIMs owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSimsAsync($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        return $this->getGroupSimsAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $offset, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupSimsAsyncWithHttpInfo
     *
     * Get SIMs owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSimsAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseSim';
        $request = $this->getGroupSimsRequest($distributor_id, $group_id, $request_id, $offset, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupSims'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupSimsRequest($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroupSims'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupSims'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/sims';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, 'int32');
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGroupSubgroups
     *
     * Get sub-groups owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseListResponseGroup
     */
    public function getGroupSubgroups($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        list($response) = $this->getGroupSubgroupsWithHttpInfo($distributor_id, $group_id, $request_id, $offset, $count);
        return $response;
    }

    /**
     * Operation getGroupSubgroupsWithHttpInfo
     *
     * Get sub-groups owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseListResponseGroup, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGroupSubgroupsWithHttpInfo($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseGroup';
        $request = $this->getGroupSubgroupsRequest($distributor_id, $group_id, $request_id, $offset, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseListResponseGroup',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGroupSubgroupsAsync
     *
     * Get sub-groups owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSubgroupsAsync($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        return $this->getGroupSubgroupsAsyncWithHttpInfo($distributor_id, $group_id, $request_id, $offset, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGroupSubgroupsAsyncWithHttpInfo
     *
     * Get sub-groups owned by a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGroupSubgroupsAsyncWithHttpInfo($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        $returnType = '\Swagger\Client\Model\ResponseListResponseGroup';
        $request = $this->getGroupSubgroupsRequest($distributor_id, $group_id, $request_id, $offset, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGroupSubgroups'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     * @param  int $offset The offset of the first row to return, the first row is 0, not 1 (optional, default to 0)
     * @param  int $count The maximum number of rows to return (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGroupSubgroupsRequest($distributor_id, $group_id, $request_id = null, $offset = '0', $count = '10')
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling getGroupSubgroups'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling getGroupSubgroups'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/subGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, 'int32');
        }
        // query params
        if ($count !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($count, 'int32');
        }
        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setGroupOverdraft
     *
     * Set the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupOverdraft $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setGroupOverdraft($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->setGroupOverdraftWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation setGroupOverdraftWithHttpInfo
     *
     * Set the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupOverdraft $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setGroupOverdraftWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->setGroupOverdraftRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setGroupOverdraftAsync
     *
     * Set the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupOverdraft $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setGroupOverdraftAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->setGroupOverdraftAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setGroupOverdraftAsyncWithHttpInfo
     *
     * Set the overdraft of a group
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupOverdraft $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setGroupOverdraftAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->setGroupOverdraftRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setGroupOverdraft'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupOverdraft $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setGroupOverdraftRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling setGroupOverdraft'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling setGroupOverdraft'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/overdraft';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setGroupParent
     *
     * Set a group parent
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupParent $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setGroupParent($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->setGroupParentWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation setGroupParentWithHttpInfo
     *
     * Set a group parent
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupParent $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setGroupParentWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->setGroupParentRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setGroupParentAsync
     *
     * Set a group parent
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupParent $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setGroupParentAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->setGroupParentAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setGroupParentAsyncWithHttpInfo
     *
     * Set a group parent
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupParent $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setGroupParentAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->setGroupParentRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setGroupParent'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestGroupParent $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setGroupParentRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling setGroupParent'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling setGroupParent'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/setParent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateALegDataEntries
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegDataEntry[] $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateALegDataEntries($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->updateALegDataEntriesWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation updateALegDataEntriesWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegDataEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateALegDataEntriesWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegDataEntriesRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateALegDataEntriesAsync
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegDataEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegDataEntriesAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->updateALegDataEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateALegDataEntriesAsyncWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Data service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegDataEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegDataEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegDataEntriesRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateALegDataEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegDataEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateALegDataEntriesRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling updateALegDataEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling updateALegDataEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/dataalegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateALegSmsEntries
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegSmsEntry[] $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateALegSmsEntries($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->updateALegSmsEntriesWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation updateALegSmsEntriesWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegSmsEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateALegSmsEntriesWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegSmsEntriesRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateALegSmsEntriesAsync
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegSmsEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegSmsEntriesAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->updateALegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateALegSmsEntriesAsyncWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for SMS service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegSmsEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegSmsEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegSmsEntriesRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateALegSmsEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegSmsEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateALegSmsEntriesRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling updateALegSmsEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling updateALegSmsEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/smsalegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateALegVoiceEntries
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegVoiceEntry[] $body body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateALegVoiceEntries($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $this->updateALegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $body, $request_id);
    }

    /**
     * Operation updateALegVoiceEntriesWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegVoiceEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateALegVoiceEntriesWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegVoiceEntriesRequest($distributor_id, $group_id, $body, $request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateALegVoiceEntriesAsync
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegVoiceEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegVoiceEntriesAsync($distributor_id, $group_id, $body = null, $request_id = null)
    {
        return $this->updateALegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body, $request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateALegVoiceEntriesAsyncWithHttpInfo
     *
     * Update (or create if non-existent) rate entries of A Leg for a given Group for Voice service
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegVoiceEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateALegVoiceEntriesAsyncWithHttpInfo($distributor_id, $group_id, $body = null, $request_id = null)
    {
        $returnType = '';
        $request = $this->updateALegVoiceEntriesRequest($distributor_id, $group_id, $body, $request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateALegVoiceEntries'
     *
     * @param  int $distributor_id The unique identifier of a distributor (required)
     * @param  int $group_id The unique identifier of a group (required)
     * @param  \Swagger\Client\Model\RequestALegVoiceEntry[] $body (optional)
     * @param  string $request_id It will be returned in the response header, the purpose of the RequestId to provide a reference ID to the client side developer if one is using a asynchronous system (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateALegVoiceEntriesRequest($distributor_id, $group_id, $body = null, $request_id = null)
    {
        // verify the required parameter 'distributor_id' is set
        if ($distributor_id === null || (is_array($distributor_id) && count($distributor_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distributor_id when calling updateALegVoiceEntries'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling updateALegVoiceEntries'
            );
        }

        $resourcePath = '/{distributorId}/group/{groupId}/voicealegrates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($request_id !== null) {
            $headerParams['RequestId'] = ObjectSerializer::toHeaderValue($request_id);
        }

        // path params
        if ($distributor_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distributorId' . '}',
                ObjectSerializer::toPathValue($distributor_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
